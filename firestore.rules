/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for most data,
 * ensuring that users can only access and modify their own data.
 * Public read access is granted in select cases to public collections.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - Courses, roadmaps, notes, chat sessions, quiz attempts/results, calendar events, podcast episodes,
 *   SAT test results/study sessions are stored in top-level collections,
 *   and each document contains a `userId` field linking it to the owner.
 * - Squads are stored under `/squads/{squadId}`, with access controlled by `ownerId` and `members` list.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Courses, roadmaps, notes, chat sessions, quiz attempts/results, calendar events, podcast episodes,
 *   and SAT results/study sessions are private and accessible only to the owner.
 * - Squads are collaborative and managed by an owner with shared access for members.
 * - Data validation is relaxed in this prototyping phase, focusing only on authorization checks and relational integrity.
 *
 * Denormalization for Authorization:
 * The `userId` field is used throughout the database to link documents to their owners.
 * For squads, `ownerId` and `members` fields are used for collaborative access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(docId) {
      return isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (get, update, delete) if the user is the owner of the profile.
     * @allow (create) if the user is creating their own profile.
     * @deny (get, update, delete) if the user is not the owner of the profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to course data.
     * @path /courses/{courseId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the course.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the course.
     * @principle Enforces user-owned course data with public read access.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(courseId);
      allow delete: if isSignedIn() && isExistingOwner(courseId);
    }

    /**
     * @description Controls access to roadmaps.
     * @path /roadmaps/{roadmapId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the roadmap.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the roadmap.
     * @principle Enforces user-owned roadmap data with public read access.
     */
    match /roadmaps/{roadmapId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(roadmapId);
      allow delete: if isSignedIn() && isExistingOwner(roadmapId);
    }

    /**
     * @description Controls access to notes.
     * @path /notes/{noteId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the note.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the note.
     * @principle Enforces user-owned note data with public read access.
     */
    match /notes/{noteId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(noteId);
      allow delete: if isSignedIn() && isExistingOwner(noteId);
    }

    /**
     * @description Controls access to chat sessions.
     * @path /chatSessions/{sessionId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the chat session.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the chat session.
     * @principle Enforces user-owned chat session data with public read access.
     */
    match /chatSessions/{sessionId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(sessionId);
      allow delete: if isSignedIn() && isExistingOwner(sessionId);
    }

    /**
     * @description Controls access to quiz attempts.
     * @path /quizAttempts/{attemptId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the quiz attempt.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the quiz attempt.
     * @principle Enforces user-owned quiz attempt data with public read access.
     */
    match /quizAttempts/{attemptId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(attemptId);
      allow delete: if isSignedIn() && isExistingOwner(attemptId);
    }

    /**
     * @description Controls access to quiz results.
     * @path /quizResults/{resultId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the quiz result.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the quiz result.
     * @principle Enforces user-owned quiz result data with public read access.
     */
    match /quizResults/{resultId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resultId);
      allow delete: if isSignedIn() && isExistingOwner(resultId);
    }

    /**
     * @description Controls access to calendar events.
     * @path /calendarEvents/{eventId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the calendar event.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the calendar event.
     * @principle Enforces user-owned calendar event data with public read access.
     */
    match /calendarEvents/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(eventId);
      allow delete: if isSignedIn() && isExistingOwner(eventId);
    }

    /**
     * @description Controls access to squads.
     * @path /squads/{squadId}
     * @allow (get, list) if the user is the owner or a member of the squad.
     * @allow (create) if the user is creating the squad and sets ownerId to their UID.
     * @allow (update, delete) if the user is the owner of the squad.
     * @deny (create) if the user is not setting ownerId to their UID.
     * @deny (update, delete) if the user is not the owner of the squad.
     * @principle Enforces owner-managed collaborative group access.
     */
    match /squads/{squadId} {
        function isSquadMember() {
            return isSignedIn() && (resource.data.ownerId == request.auth.uid || (resource.data.members is list && request.auth.uid in resource.data.members));
        }

        allow get, list: if isSquadMember();
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
        allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
        allow delete: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
    }

     /**
     * @description Controls access to podcast episodes.
     * @path /podcastEpisodes/{episodeId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the podcast episode.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the podcast episode.
     * @principle Enforces user-owned podcast episode data with public read access.
     */
    match /podcastEpisodes/{episodeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(episodeId);
      allow delete: if isSignedIn() && isExistingOwner(episodeId);
    }

     /**
     * @description Controls access to SAT test results.
     * @path /satTestResults/{resultId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the SAT test result.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the SAT test result.
     * @principle Enforces user-owned SAT test result data with public read access.
     */
    match /satTestResults/{resultId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resultId);
      allow delete: if isSignedIn() && isExistingOwner(resultId);
    }

     /**
     * @description Controls access to SAT study sessions.
     * @path /satStudySessions/{sessionId}
     * @allow (get, list) if true (public read access).
     * @allow (create) if the userId matches the authenticated user.
     * @allow (update, delete) if the user is the owner of the SAT study session.
     * @deny (create) if the userId does not match the authenticated user.
     * @deny (update, delete) if the user is not the owner of the SAT study session.
     * @principle Enforces user-owned SAT study session data with public read access.
     */
    match /satStudySessions/{sessionId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(sessionId);
      allow delete: if isSignedIn() && isExistingOwner(sessionId);
    }
  }
}